<html>
<head>
	<title>Morrowind</title>

	<meta http-equiv="cache-control" content="max-age=0" />
	<meta http-equiv="cache-control" content="no-cache" />
	<meta http-equiv="expires" content="0" />
	<meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
	<meta http-equiv="pragma" content="no-cache" />
		
	<script src="js/jquery-2.1.3.min.js"></script>

	<script src="three.js-master/build/three.min.js"></script>
	<script src="three.js-master/examples/js/libs/stats.min.js"></script>

	<script src="three.js-master/examples/js/controls/PointerLockControls.js"></script>
	<script src="three.js-master/examples/js/Mirror.js"></script>
	<script src="three.js-master/examples/js/WaterShader.js"></script>

	<script src="three.js-master/examples/js/loaders/DDSLoader.js"></script>
	<script src="three.js-master/examples/js/loaders/ColladaLoader.js"></script>
	<script src="three.js-master/examples/js/loaders/collada/Animation.js"></script>
	<script src="three.js-master/examples/js/loaders/collada/AnimationHandler.js"></script>
	<script src="three.js-master/examples/js/loaders/collada/KeyFrameAnimation.js"></script>

	<script src="three.js-master/examples/js/loaders/sea3d/SEA3D.js"></script>
	<script src="three.js-master/examples/js/loaders/sea3d/SEA3DLZMA.js"></script>
	<script src="three.js-master/examples/js/loaders/sea3d/SEA3DLoader.js"></script>
	
	<!--<script src="three.js-master/examples/js/controls/FirstPersonControls.js"></script>-->
	<script src="js/dat.gui.min.js"></script>


	<script src="js/FirstPersonControls.js"></script>
	<script src="js/morrowind.js"></script>
	<script src="js/toolshack.js"></script>
	<script src="js/engine.js"></script>
	<script src="js/net.js"></script>
	<script src="js/world.js"></script>
	<script src="js/water.js"></script>
	<script src="js/cell.js"></script>
	<script src="js/terrain.js"></script>
	<script src="js/prop.js"></script>
	<script src="js/grass.js"></script>
	<script src="js/ship.js"></script>
	<script src="js/player.js"></script>

	<style>
		body {
			margin: 0;
			background: blue;
		}

		acanvas {
			position: relative;
		}
	</style>
</head>
<body>

<!-- <iframe style="display: none" id="audio" width="1280" height="720" src="https://www.youtube.com/embed/hnz3t2RN0ns?rel=0&amp;controls=0&amp;showinfo=0&amp;autoplay=1" frameborder="0" allowfullscreen=""></iframe> -->
<!-- <iframe style="display: none" id="audio" width="1280" height="720" src="https://www.youtube.com/embed/KjjKSJFz68s?rel=0&amp;controls=0&amp;showinfo=0&amp;autoplay=1" frameborder="0" allowfullscreen=""></iframe> -->

<script id="vertexShader" type="x-shader/x-vertex">
varying vec2 vUv;
void main() 
{ 
	vUv = uv;
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}
</script>

<script id="fragmentShader" type="x-shader/x-vertex"> 
uniform sampler2D baseTexture;
uniform float baseSpeed;
uniform sampler2D noiseTexture;
uniform float noiseScale;
uniform float alpha;
uniform float time;

varying vec2 vUv;
void main() 
{
	vec2 uvTimeShift = vUv + vec2( -0.7, 1.5 ) * time * baseSpeed;	
	vec4 noiseGeneratorTimeShift = texture2D( noiseTexture, uvTimeShift );
	vec2 uvNoiseTimeShift = vUv + noiseScale * vec2( noiseGeneratorTimeShift.r, noiseGeneratorTimeShift.b );
	vec4 baseColor = texture2D( baseTexture, uvNoiseTimeShift );

	baseColor.a = alpha;
	gl_FragColor = baseColor;
}  
</script>

<script id="splatVertexShader" type="x-shader/x-vertex">
#define LAMBERT

varying vec3 vLightFront;

#ifdef DOUBLE_SIDED

	varying vec3 vLightBack;

#endif

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars>
#include <color_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

varying vec2 vUv;

void main() {

	vUv = uv;

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>

	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>

	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>

	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>

}
</script>

<script id="splatFragmentShader" type="x-shader/x-vertex">
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;

varying vec3 vLightFront;

#ifdef DOUBLE_SIDED

	varying vec3 vLightBack;

#endif

#include <common>
#include <packing>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_pars_fragment>
#include <bsdfs>
#include <lights_pars>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

// START MW
varying vec2 vUv;

uniform sampler2D pastels[ 6 ];
uniform int amount;

uniform sampler2D cat;
uniform sampler2D vclr;

uniform sampler2D masks[ 3 ];
// END MW

void main() {

	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;

	#include <logdepthbuf_fragment>
	#include <map_fragment>

	// START MW
	{
		//diffuseColor = texture2D(cat, vUv * 16.0);

		vec2 uv1 = vUv;

		//  0.9846153846153846 1.015625
		vec4 coat = vec4(0.0);
		vec4 mask = vec4(0.0);
		float p = 0.0;
		vec4 pastel = texture2D(pastels[0], vUv * 16.0);

		mask = texture2D(masks[0], vUv);

		p = mask.g;
		coat = vec4(p, p, p, 0) * pastel;

		vec2 uv = vUv + 0.0078125;

		vec4 shading = texture2D(vclr, uv * 0.5) * 2.0;

		diffuseColor *= pastel * shading;
	}
	// END MW 

	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>

	// accumulation
	reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );

	#include <lightmap_fragment>

	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );

	#ifdef DOUBLE_SIDED

		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;

	#else

		reflectedLight.directDiffuse = vLightFront;

	#endif

	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();

	// modulation
	#include <aomap_fragment>

	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;

	#include <envmap_fragment>

	gl_FragColor = vec4( outgoingLight, diffuseColor.a );

	#include <premultiplied_alpha_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>

}
</script>

<!--

-->

</body>
</html>