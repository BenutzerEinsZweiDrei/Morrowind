// Generated by CoffeeScript 1.9.1
(function() {
  mw.World = (function() {
    function World(data) {
      var i, j, k, len, p, ref;
      this.data = data;
      this.x = -2;
      this.y = -9;
      this.cells = [];
      for (i = j = 0; j <= 8; i = ++j) {
        this.cells.push(new mw.Cell(this.x + mw.circle[i].x, this.y + mw.circle[i].y));
      }
      this.props = [];
      this.cached = 0;
      this.queue = 0;
      ref = this.data;
      for (k = 0, len = ref.length; k < len; k++) {
        p = ref[k];
        if (typeof p === "object") {
          this.cache(p.model);
        }
      }
      this.watershed();
    }

    World.prototype.doskybox = function() {
      var geometry, loader;
      geometry = new THREE.CubeGeometry(8192 * 2, 8192 * 2, 8192 * 2);
      loader = new THREE.TGALoader;
      loader.load('models/tx_sky_clear.tga', function(asd) {
        var array, i, j, material;
        asd.wrapS = asd.wrapT = THREE.RepeatWrapping;
        array = [];
        for (i = j = 0; j <= 5; i = ++j) {
          array.push(new THREE.MeshBasicMaterial({
            map: asd,
            side: THREE.BackSide
          }));
        }
        material = new THREE.MeshFaceMaterial(array);
        this.skybox = new THREE.Mesh(geometry, material);
        this.skybox.position.set(mw.terrain.mx, mw.terrain.my, -500);
        return mw.scene.add(this.skybox);
      });
      return true;
    };

    World.prototype.cachcb = function() {
      this.cached++;
      if (this.cached >= this.queue) {
        this.ransack();
      }
      return true;
    };

    World.prototype.ransack = function() {
      var j, len, p, ref;
      ref = this.data;
      for (j = 0, len = ref.length; j < len; j++) {
        p = ref[j];
        if (typeof p === "object") {
          this.props.push(new mw.Prop(p));
        }
      }
      return true;
    };

    World.prototype.cache = function(model) {
      var cb, loader;
      this.queue++;
      cb = function(object) {
        var c, i, j, len, ref;
        mw.models[model] = object;
        ref = object.children;
        for (i = j = 0, len = ref.length; j < len; i = ++j) {
          c = ref[i];
          if (c.material.map) {
            c.material.map.needsUpdate = true;
            c.material.map.onUpdate = function() {
              if (this.wrapS !== THREE.RepeatWrapping || this.wrapT !== THREE.RepeatWrapping) {
                this.wrapS = THREE.RepeatWrapping;
                this.wrapT = THREE.RepeatWrapping;
                return this.needsUpdate = true;
              }
            };
          }
        }
        return mw.world.cachcb();
      };
      loader = new THREE.OBJMTLLoader;
      loader.load("models/" + model + ".obj", "models/" + model + ".mtl", cb);
      return true;
    };

    World.prototype.watershed = function() {
      var geometry, x, y;
      THREE.ShaderLib['mirror'].uniforms.opacity = {
        type: "f",
        value: .6
      };
      THREE.ShaderLib['mirror'].fragmentShader = "uniform float opacity; uniform vec3 mirrorColor; uniform sampler2D mirrorSampler; varying vec4 mirrorCoord; float blendOverlay(float base, float blend) { return( base < 0.5 ? ( 2.0 * base * blend ) : (1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) ); } void main() { vec4 color = texture2DProj(mirrorSampler, mirrorCoord); color = vec4(blendOverlay(mirrorColor.r, color.r), blendOverlay(mirrorColor.g, color.g), blendOverlay(mirrorColor.b, color.b), opacity); gl_FragColor = color; }";
      mw.watertga.wrapS = mw.watertga.wrapT = THREE.RepeatWrapping;
      mw.watertga.repeat.set(64, 64);
      this.mirror = new THREE.Mirror(mw.renderer, mw.camera, {
        clipBias: 0.0025,
        textureWidth: 1024,
        textureHeight: 1024,
        color: 0x777777
      });
      this.mirror.material.transparent = true;
      geometry = new THREE.PlaneBufferGeometry(8192 * 6, 8192 * 6, 64, 64);
      this.waterMaterial = new THREE.MeshLambertMaterial({
        map: mw.watertga,
        transparent: true,
        opacity: .6
      });
      this.water = THREE.SceneUtils.createMultiMaterialObject(geometry, [this.mirror.material, this.waterMaterial]);
      this.water.add(this.mirror);
      x = (this.x * 8192) + 4096 - 128;
      y = (this.y * 8192) + 4096 + 128;
      this.water.position.set(x, y, 0);
      mw.scene.add(this.water);
      console.log('added water');
      return true;
    };

    return World;

  })();

}).call(this);
