// Generated by CoffeeScript 1.9.1
(function() {
  mw.Terrain = (function() {
    function Terrain() {
      var that;
      this.bmp = new Image(64, 64);
      this.bmp.src = 'cells/-2,-9.bmp';
      that = this;
      this.bmp.onload = function() {
        return that.got();
      };
    }

    Terrain.prototype.got = function() {
      var d, h, i, j, map, mx, my, p, px, py, ref, x, y;
      this.data = this.heights();
      this.geometry = new THREE.PlaneGeometry(8192 * 2, 8192 * 2, 128, 128);
      map = THREE.ImageUtils.loadTexture('seydaneen.bmp');
      map.magFilter = THREE.NearestFilter;
      map.minFilter = THREE.LinearMipMapLinearFilter;
      this.material = new THREE.MeshBasicMaterial({
        map: map,
        wireframe: true
      });
      this.mesh = new THREE.Mesh(this.geometry, this.material);
      this.mx = mx = (-2 * 8192) + 4096 + 512 + 128;
      this.my = my = (-9 * 8192) + 256 + 128;
      console.log("mx " + mx + ", my " + my);
      this.mesh.position.set(mx, my, 0);
      for (i = j = 0, ref = this.geometry.vertices.length - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
        x = this.geometry.vertices[i].x;
        y = this.geometry.vertices[i].y;
        px = (((-2 * 8192) + x) / 128) + 128 + 64;
        py = (((-9 * 8192) + y) / 128) + 512 + 128;
        p = (py * 128 + px) * 4;
        this.geometry.colors[i] = 200;
        d = this.data[p + 2] || 0;
        if (d) {
          if (this.data[p + 0] === 255 && this.data[p + 1] === 255) {
            h = -(255 - d) * 2;
            this.geometry.vertices[i].z = h;
          } else {
            this.geometry.vertices[i].z = d * 2;
          }
        } else {
          this.geometry.vertices[i].z = 1;

          /*geometry = new THREE.BoxGeometry 1, 1, 1
          				material = new THREE.MeshBasicMaterial color: 0x00ff00
          				cube = new THREE.Mesh geometry, material
          				cube.position.set mx, my, 1
          				mw.scene.add cube
           */
        }
      }
      this.geometry.colorsNeedUpdate = true;
      mw.scene.add(this.mesh);
      this.water();
      return true;
    };

    Terrain.prototype.heights = function() {
      var canvas, context, data, i, img, imgd, j, ref, ref1, size;
      console.log('heights');
      img = this.bmp;
      canvas = document.createElement('canvas');
      canvas.width = 128;
      canvas.height = 128;
      context = canvas.getContext('2d');
      size = 128 * 128;
      data = new Float32Array(size);
      context.drawImage(img, 0, 0);
      for (i = j = ref = i, ref1 = i - size - 1; ref <= ref1 ? j <= ref1 : j >= ref1; i = ref <= ref1 ? ++j : --j) {
        data[i] = 0;
      }
      imgd = context.getImageData(0, 0, 128, 128);
      return imgd.data;

      /*j=0
      		n = pix.length
      		for i in [0..n-1] by 4
      			all = pix[i]+pix[i+1]+pix[i+2]
      			data[j++] = all/30
       */
    };

    Terrain.prototype.water = function() {
      var loader, that;
      that = this;
      loader = new THREE.TGALoader;
      loader.load('models/water00.tga', function(asd) {
        var geometry, material, mesh;
        asd.wrapS = asd.wrapT = THREE.RepeatWrapping;
        asd.repeat.set(32, 32);
        geometry = new THREE.PlaneGeometry(8192 * 2, 8192 * 2, 64, 64);
        material = new THREE.MeshBasicMaterial({
          map: asd,
          transparent: true,
          opacity: .5
        });
        mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(that.mx, that.my, 0);
        console.log(mesh);
        return mw.scene.add(mesh);
      });
      return true;
    };

    return Terrain;

  })();

}).call(this);
