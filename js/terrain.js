// Generated by CoffeeScript 1.9.1
(function() {
  mw.Terrain = (function() {
    function Terrain(x1, y1) {
      var b, g, h, i, j, k, l, mS, mesh, mx, my, n, p, px, py, r, ref, ref1, x, y;
      this.x = x1;
      this.y = y1;
      this.maps();
      this.soul();
      this.geometry = new THREE.PlaneGeometry(8192, 8192, 64, 64);
      this.mx = mx = (this.x * 8192) + 4096;
      this.my = my = (this.y * 8192) + 4096;
      this.patch = new THREE.Geometry;
      this.patch.vertices = [new THREE.Vector3(0, 128, 0), new THREE.Vector3(128, 128, 0), new THREE.Vector3(0, 0, 0), new THREE.Vector3(128, 0, 0), new THREE.Vector3(0, -128, 0), new THREE.Vector3(0, 0, 0), new THREE.Vector3(128, -128, 0), new THREE.Vector3(128, 0, 0), new THREE.Vector3(0, -128, 0), new THREE.Vector3(-128, -128, 0), new THREE.Vector3(0, 0, 0), new THREE.Vector3(-128, 0, 0), new THREE.Vector3(0, 128, 0), new THREE.Vector3(0, 0, 0), new THREE.Vector3(-128, 128, 0), new THREE.Vector3(-128, 0, 0)];
      this.patch.faces = [new THREE.Face3(0, 2, 1), new THREE.Face3(2, 3, 1), new THREE.Face3(4, 6, 5), new THREE.Face3(6, 7, 5), new THREE.Face3(8, 10, 9), new THREE.Face3(10, 11, 9), new THREE.Face3(12, 14, 13), new THREE.Face3(14, 15, 13)];
      this.patch.verticesNeedUpdate = true;
      this.patch.elementsNeedUpdate = true;
      this.patch.morphTargetsNeedUpdate = true;
      this.patch.uvsNeedUpdate = true;
      this.patch.normalsNeedUpdate = true;
      this.patch.colorsNeedUpdate = true;
      this.patch.tangentsNeedUpdate = true;

      /*
      		 * create ground patch
      		array = [[0, 0], [0, -1], [-1, -1], [-1, 0]]
      		Neo = (new THREE.Matrix4()).identity()
      		for i in [0..3]
      			patch = new THREE.PlaneGeometry 128, 128, 1, 1
      
      			r = (i*90) * Math.PI / 180
      
      			Neo.makeRotationZ r
      
      			patch.applyMatrix Neo
      
      			j = i #Math.abs i-3
      
      			for i in [0..patch.vertices.length-1]
      				patch.vertices[i].x = patch.vertices[i].x + (array[j][0]*128)
      				patch.vertices[i].y = patch.vertices[i].y + (array[j][1]*128)
      
      			@patch.merge patch
      
      		console.log @patch
       */
      this.patches = new THREE.Geometry;
      for (y = j = 0; j <= 31; y = ++j) {
        for (x = k = 0; k <= 31; x = ++k) {
          g = this.patch.clone();
          for (i = l = 0, ref = g.vertices.length - 1; 0 <= ref ? l <= ref : l >= ref; i = 0 <= ref ? ++l : --l) {
            g.vertices[i].x += ((x - 16) * 256) + 128;
            g.vertices[i].y += ((y - 16) * 256) + 128;
          }
          this.patches.merge(g);
        }
      }
      mw.assignUVs(this.patches);
      if (this.x === -2 && this.y === -9) {
        this.geometry = this.patches;
        mesh = new THREE.Mesh(this.geometry, new THREE.MeshBasicMaterial({
          wireframe: true
        }));
        mesh.position.set(mx, my, 0);
        mw.scene.add(mesh);
      } else {
        mS = (new THREE.Matrix4()).identity();
        mS.elements[0] = -1;
        mS.elements[10] = -1;
        this.geometry.applyMatrix(mS);
        mesh = new THREE.Mesh(this.geometry, mw.wireframe);
        mesh.position.set(mx, my, 0);
        mw.scene.add(mesh);
      }
      for (i = n = 0, ref1 = this.geometry.vertices.length - 1; 0 <= ref1 ? n <= ref1 : n >= ref1; i = 0 <= ref1 ? ++n : --n) {
        x = this.geometry.vertices[i].x;
        y = this.geometry.vertices[i].y;
        px = (4096 + x) / 64;
        px /= 2;
        py = (4096 + y) / 64;
        py /= 2;
        p = ((py * 65) + px) * 4;
        r = this.heights[p];
        g = this.heights[p + 1];
        b = this.heights[p + 2];
        if (r === 255) {
          this.geometry.vertices[i].z = h;
          h = -(255 - b) + (255 * ((g - 255) / 8));
        } else if (g) {
          h = (255 * (g / 8)) + b;
        } else {
          h = b;
        }
        this.geometry.vertices[i].z = h;
      }
      this.mkground();
      true;
    }

    Terrain.prototype.mkground = function() {
      var m;
      m = new THREE.MeshBasicMaterial({
        map: mw.textures['tx_bc_mud.dds']
      });
      this.ground = new THREE.Mesh(this.geometry, this.splat());
      this.ground.position.set(this.mx, this.my, 0);
      mw.scene.add(this.ground);
      return true;
    };

    Terrain.prototype.maps = function() {
      var canvas, context, x, y;
      canvas = document.createElement('canvas');
      context = canvas.getContext('2d');
      canvas.width = 65;
      canvas.height = 65;
      context.save();
      context.translate(1, 65);
      context.scale(1, -1);
      x = -(18 + this.x) * 64;
      y = -(27 - this.y) * 64;
      context.drawImage(mw.vvardenfell, x, y);
      context.getImageData(0, 0, 65, 65);
      this.heights = context.getImageData(0, 0, 65, 65).data;
      context.restore();
      context.drawImage(mw.vvardenfell, x, y);
      this.height = new THREE.Texture(canvas);
      this.height.needsUpdate = true;
      this.height.magFilter = THREE.NearestFilter;
      this.height.minFilter = THREE.LinearMipMapLinearFilter;
      canvas = document.createElement('canvas');
      context = canvas.getContext('2d');
      canvas.width = 65;
      canvas.height = 65;
      context.restore();
      context.translate(1, 0);
      context.drawImage(mw.vclr, x, y);
      this.vclr = new THREE.Texture(canvas);
      this.vclr.needsUpdate = true;
      canvas = document.createElement('canvas');
      canvas.width = 18;
      canvas.height = 18;
      context = canvas.getContext('2d');
      context.translate(1, 1);
      context.drawImage(mw.vtex, x / 4, y / 4);
      this.blues = context.getImageData(0, 0, 18, 18).data;
      return true;
    };

    Terrain.prototype.soul = function() {
      var b, blues, canvas, color, context, data, i, j, k, l, len, len1, m, n, ref, ref1, ref2, t, v;
      this.masks = [];
      this.textures = [];
      blues = [];
      for (i = j = 0, ref = this.blues.length / 4; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
        b = this.blues[(i * 4) + 2];
        if (blues.indexOf(b) === -1) {
          blues.push(b);
        }
      }
      color = 3;
      for (k = 0, len = blues.length; k < len; k++) {
        b = blues[k];
        if (mw.blues[b]) {
          this.textures.push(mw.textures[mw.blues[b]]);
        }
        if (++color === 4) {
          canvas = document.createElement('canvas');
          $(canvas).attr('mw', "cell " + this.x + ", " + this.y);
          context = canvas.getContext('2d');
          canvas.width = 18;
          canvas.height = 18;
          color = 0;
          data = context.createImageData(18, 18);
          this.masks.push(canvas);
        }
        for (i = l = 0, ref1 = this.blues.length / 4; 0 <= ref1 ? l <= ref1 : l >= ref1; i = 0 <= ref1 ? ++l : --l) {
          v = this.blues[(i * 4) + 2];
          data.data[(i * 4) + color] = v === b ? 255 : 1;
        }
        context.putImageData(data, 0, 0);
      }
      ref2 = this.masks;
      for (i = n = 0, len1 = ref2.length; n < len1; i = ++n) {
        m = ref2[i];
        t = new THREE.Texture(m);
        t.needsUpdate = true;
        this.masks[i] = t;
      }
      while (this.textures.length > 9) {
        this.textures.pop();
      }
      return true;
    };

    Terrain.prototype.splat = function() {

      /*a = new THREE.ImageUtils.loadTexture 'cloud.png'
      		a.wrapS = a.wrapT = THREE.RepeatWrapping
      		a.repeat.set 64, 64
      		
      		b = new THREE.ImageUtils.loadTexture 'water.jpg'
      		b.wrapS = b.wrapT = THREE.RepeatWrapping
      		b.repeat.set 64, 64
       */
      var material;
      material = new THREE.ShaderMaterial({
        uniforms: {
          vertexColour: {
            type: "t",
            value: this.vclr
          },
          uTextures: {
            type: "tv",
            value: this.textures
          },
          amount: {
            type: "i",
            value: this.textures.length
          },
          uMasks: {
            type: "tv",
            value: this.masks
          },
          fogColor: {
            type: "c",
            value: mw.scene.fog.color
          },
          fogDensity: {
            type: "f",
            value: mw.scene.fog.density
          },
          fogNear: {
            type: "f",
            value: mw.scene.fog.near
          },
          fogFar: {
            type: "f",
            value: mw.scene.fog.far
          }
        },
        vertexShader: document.getElementById('splatVertexShader').textContent,
        fragmentShader: document.getElementById('splatFragmentShader').textContent,
        fog: true,
        transparent: true,
        side: THREE.DoubleSide
      });
      return material;
    };

    return Terrain;

  })();

}).call(this);
