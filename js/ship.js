// Generated by CoffeeScript 1.10.0
(function() {
  var extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  mw.Ship = (function(superClass) {
    extend(Ship, superClass);

    function Ship(data) {
      Ship.__super__.constructor.call(this, data);
      this.mesh.matrixAutoUpdate = true;
      this.type = 'Ship';
      mw.ship = this;
      this.nodes = [
        {
          x: -8768.043459278077,
          y: -76317.46448975372,
          z: 214.69864753075956
        }, {
          x: -11008.29662446419,
          y: -77440.86070491183,
          z: 208.28192393984938
        }, {
          x: -15064.698398200067,
          y: -78235.1147036306,
          z: 311.9163745306073
        }, {
          x: -17700.894481160587,
          y: -72703.35435825039,
          z: 121.48177096281158
        }, {
          x: -21053.005749845994,
          y: -71397.26995136919,
          z: 155.7574808565444
        }
      ];
      this.nodes.unshift({
        x: this.x,
        y: this.y,
        z: this.z
      });
      this.mesh.add(mw.shipping);
      this.buoys();
      this.knots = 2;
      this.belongings = [];
      this.shenanigans();
      this.node = 0;
      this.goal = 1;
      this.linear = {
        heave: 0,
        sway: 0,
        surge: 0
      };
      this.rotations = {
        course: {
          value: 0,
          period: 0
        },
        pitch: {
          value: 0,
          period: 0
        },
        roll: {
          value: 0,
          period: 0
        },
        yaw: {
          value: 0,
          period: 0
        }
      };
    }

    Ship.prototype.shenanigans = function() {
      var barrel, crate, door, prop, trapdoor, x, y, z;
      door = {
        model: 'ex_de_ship_door',
        x: -7918.463,
        y: -72870.719,
        z: 238.412,
        r: 45.0,
        scale: 1.08
      };
      x = door.x - this.x;
      y = door.y - this.y;
      z = door.z - this.z;
      prop = mw.factory(door);
      this.belongings.push(prop);
      THREE.SceneUtils.attach(prop.mesh, mw.scene, this.mesh);
      prop.mesh.updateMatrixWorld();
      THREE.SceneUtils.attach(mw.camera, mw.scene, this.mesh);
      mw.camera.updateMatrixWorld();
      crate = {
        model: 'contain_crate_01',
        x: -7932.143,
        y: -73255.852,
        z: 217.178,
        r: 225.0
      };
      prop = mw.factory(crate);
      this.belongings.push(prop);
      THREE.SceneUtils.attach(prop.mesh, mw.scene, this.mesh);
      prop.mesh.updateMatrixWorld();
      crate = {
        model: 'contain_crate_01',
        x: -7862.265,
        y: -73173.664,
        z: 217.136,
        r: 274.9
      };
      prop = mw.factory(crate);
      this.belongings.push(prop);
      THREE.SceneUtils.attach(prop.mesh, mw.scene, this.mesh);
      prop.mesh.updateMatrixWorld();
      crate = {
        model: 'contain_crate_01',
        x: -7812.131,
        y: -73111.852,
        z: 217.136,
        r: 315.0
      };
      prop = mw.factory(crate);
      this.belongings.push(prop);
      THREE.SceneUtils.attach(prop.mesh, mw.scene, this.mesh);
      prop.mesh.updateMatrixWorld();
      crate = {
        model: 'contain_crate_01',
        x: -8406.916,
        y: -73219.922,
        z: 218.796,
        r: 360.0
      };
      prop = mw.factory(crate);
      this.belongings.push(prop);
      THREE.SceneUtils.attach(prop.mesh, mw.scene, this.mesh);
      prop.mesh.updateMatrixWorld();
      barrel = {
        model: 'contain_barrel_01',
        x: -8924.142,
        y: -73951.859,
        z: 265.178,
        r: 360.0
      };
      prop = mw.factory(barrel);
      this.belongings.push(prop);
      THREE.SceneUtils.attach(prop.mesh, mw.scene, this.mesh);
      prop.mesh.updateMatrixWorld();
      barrel = {
        model: 'contain_barrel_01',
        x: -8948.135,
        y: -74023.852,
        z: 265.178,
        r: 360.0
      };
      prop = mw.factory(barrel);
      this.belongings.push(prop);
      THREE.SceneUtils.attach(prop.mesh, mw.scene, this.mesh);
      prop.mesh.updateMatrixWorld();
      trapdoor = {
        model: 'ex_de_ship_trapdoor',
        x: -8584.352,
        y: -73710.805,
        z: 233.497,
        r: 45.0
      };
      prop = mw.factory(trapdoor);
      this.belongings.push(prop);
      THREE.SceneUtils.attach(prop.mesh, mw.scene, this.mesh);
      prop.mesh.updateMatrixWorld();
      return 0;
    };

    Ship.prototype.buoys = function() {
      var g, i, len, m, mesh, n, ref;
      ref = this.nodes;
      for (i = 0, len = ref.length; i < len; i++) {
        n = ref[i];
        g = new THREE.BoxGeometry(100, 100, 100);
        m = new THREE.MeshBasicMaterial({
          color: 0xcc0000
        });
        mesh = new THREE.Mesh(g, m);
        mesh.position.set(n.x, n.y, 0);
        mw.scene.add(mesh);
      }
      return 0;
    };

    Ship.prototype.wiggle = function() {
      var pitch, roll, yaw;
      roll = this.rotations.roll.value;
      pitch = this.rotations.pitch.value;
      yaw = this.rotations.yaw.value;
      this.mesh.rotation.x = roll + -pitch;
      this.mesh.rotation.y = roll + pitch;
    };

    Ship.prototype.step = function() {
      var r, x, y;
      Ship.__super__.step.apply(this, arguments);
      this.renode();
      x = this.x;
      y = this.y;
      r = this.r;
      this.rock();
      this.pose();
      this.wiggle();
      this.x = x;
      this.y = y;
      this.r = r;
      return false;
    };

    Ship.prototype.rock = function() {
      var lin, rot;
      rot = this.rotations;
      lin = this.linear;
      this.pitch();
      this.roll();
      this.yaw();
      this.r += rot.yaw.value;
      return 0;
    };

    Ship.prototype.yaw = function() {
      var yaw;
      yaw = this.rotations.yaw;
      yaw.period += 0.01 * mw.timestep;
      if (yaw.period > Math.PI * 2) {
        yaw.period -= Math.PI * 2;
      }
      yaw.value = 0.018 * Math.cos(yaw.period);
      return 0;
    };

    Ship.prototype.pitch = function() {
      var pitch;
      pitch = this.rotations.pitch;
      pitch.period += 0.008 * mw.timestep;
      if (pitch.period > Math.PI * 2) {
        pitch.period -= Math.PI * 2;
      }
      pitch.value = 0.014 * Math.cos(pitch.period);
      return 0;
    };

    Ship.prototype.roll = function() {
      var roll;
      roll = this.rotations.roll;
      roll.period += 0.012 * mw.timestep;
      if (roll.period > Math.PI * 2) {
        roll.period -= Math.PI * 2;
      }
      roll.value = 0.024 * Math.cos(roll.period);
      return 0;
    };

    Ship.prototype.course = function() {
      var course;
      course = this.rotations.course;
      course.period += 0.01 * mw.timestep;
      if (course.period > Math.PI) {
        course.period = Math.PI;
      }
      course.value = Math.sin(course.period);
      return 0;
    };

    Ship.prototype.renode = function() {
      var buoy, correction, diff, goal, knot, node, pitch, radians, range, x, y, yaw;
      if (this.node === this.goal) {
        return;
      }
      node = this.nodes[this.node];
      goal = this.nodes[this.goal];
      knot = this.knots * mw.timestep;
      buoy = Math.atan2(goal.y - this.y, goal.x - this.x);
      correction = Math.PI / 2;
      radians = this.r - correction;
      yaw = knot / 2100;
      pitch = Math.atan2(Math.sin(radians), Math.cos(radians));
      buoy = Math.atan2(Math.sin(buoy), Math.cos(buoy));
      diff = Math.atan2(Math.sin(pitch - buoy), Math.cos(pitch - buoy));
      this.course();
      yaw = Math.max(yaw, this.rotations.course.value * mw.timestep / 200);
      if (diff > yaw) {
        this.r -= yaw;
      } else if (diff < -yaw) {
        this.r += yaw;
      } else {
        this.r = buoy + correction;
      }
      this.x += knot * Math.cos(radians);
      this.y += knot * Math.sin(radians);
      x = Math.abs(goal.x - this.x);
      y = Math.abs(goal.y - this.y);
      range = Math.hypot(x, y);
      if (range <= 50) {
        console.log('next goal');
        this.rotations.course.period = 0;
        this.node = this.goal;
        if (this.goal + 1 < this.nodes.length) {
          this.goal++;
        } else {
          this.goal = 0;
        }
      }
      return false;
    };

    return Ship;

  })(mw.Prop);

}).call(this);
